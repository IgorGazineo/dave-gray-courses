üß† Resumo ‚Äì Aula 02 (Node.js com File System - Parte 1)

M√≥dulo nativo fs (File System) do Node.js.

üì¶ O que √© o m√≥dulo fs
O m√≥dulo fs (abrevia√ß√£o de File System) faz parte do n√∫cleo do Node.js. Ele permite que o programa interaja diretamente com o sistema de arquivos do computador.

Com ele, √© poss√≠vel:

Ler arquivos

Escrever arquivos

Renomear arquivos

Criar ou remover pastas

E muito mais

Esse m√≥dulo n√£o precisa ser instalado via npm, pois j√° vem embutido no Node.js.

‚úÖ Importa√ß√£o do m√≥dulo fs
A constante fs √© declarada e recebe o conte√∫do do m√≥dulo nativo:

const fs = require("fs");

O m√©todo require() carrega o m√≥dulo nativo do Node.js.

O argumento "fs" indica que est√° sendo carregado o m√≥dulo do sistema de arquivos.

O retorno de require("fs") √© um objeto com diversos m√©todos que permitem intera√ß√µes com o sistema de arquivos.

üìò Leitura de arquivos com fs.readFile()
O m√©todo readFile() √© utilizado para ler arquivos de forma ass√≠ncrona.

Exemplo:

fs.readFile("./files/starter.txt", (err, data) => { ... });

Detalhes:
readFile() √© um m√©todo do objeto fs

Ele √© ass√≠ncrono, ou seja, n√£o bloqueia a execu√ß√£o do restante do c√≥digo

Ele recebe dois par√¢metros obrigat√≥rios:

Caminho do arquivo (string): "./files/starter.txt"

Fun√ß√£o callback (function): (err, data) => { ... }

A fun√ß√£o callback recebe:

err: um objeto de erro, caso algo d√™ errado (por exemplo, se o arquivo n√£o existir)

data: o conte√∫do do arquivo, que vem no formato Buffer

A verifica√ß√£o if (err) throw err; garante que qualquer erro seja tratado imediatamente.

console.log(data); imprime o conte√∫do, mas como Buffer (n√£o leg√≠vel como texto).

üß† Dica: decodificando o Buffer
O conte√∫do pode ser convertido em texto com o m√©todo .toString():

console.log(data.toString());

.toString() √© um m√©todo do objeto Buffer

Retorna o conte√∫do convertido em string leg√≠vel

üí° Par√¢metro opcional: encoding
O m√©todo readFile() tamb√©m aceita um terceiro par√¢metro opcional entre o caminho e a fun√ß√£o callback.

Esse par√¢metro define a codifica√ß√£o do texto a ser lido. Por exemplo:

fs.readFile("./files/starter.txt", "utf8", (err, data) => { ... });

O valor "utf8" diz ao Node.js para retornar diretamente uma string em vez de um Buffer

Assim, o conte√∫do j√° vem pronto para ser exibido com console.log(data);

Isso elimina a necessidade de usar .toString()

Essa abordagem √© recomendada quando se deseja trabalhar diretamente com texto.

üõ°Ô∏è Tratamento de erros n√£o capturados com process.on("uncaughtException")
Esse trecho de c√≥digo √© usado para interceptar erros n√£o capturados (uncaught errors) que poderiam fazer a aplica√ß√£o travar de forma inesperada.

üîç Linha adicionada:
process.on("uncaughtException", (err) => { console.error(There was an uncaught error: ${err}); process.exit(1); });

üß† Explica√ß√£o por partes:
process
‚Äì process √© um objeto global do Node.js que fornece informa√ß√µes e controle sobre o processo em execu√ß√£o.
‚Äì Ele pode ser acessado sem a necessidade de importa√ß√£o.

on()
‚Äì O m√©todo .on() √© usado para ouvir eventos emitidos por objetos que herdam de EventEmitter, como o process.
‚Äì Sintaxe: process.on(evento, callback)

"uncaughtException"
‚Äì Esse √© o nome do evento que √© emitido quando um erro n√£o tratado (n√£o capturado por try/catch) acontece durante a execu√ß√£o do c√≥digo.
‚Äì Permite capturar esses erros antes que a aplica√ß√£o feche automaticamente.

(err) => { ... }
‚Äì Essa √© a fun√ß√£o callback que recebe o erro (err) como argumento.
‚Äì Nela, √© poss√≠vel exibir uma mensagem personalizada, registrar o erro, enviar alerta, etc.

console.error(...)
‚Äì Exibe no terminal a mensagem com o erro capturado.
‚Äì Utiliza interpola√ß√£o de string com template literals para incluir o erro na mensagem.

process.exit(1)
‚Äì Encerra a execu√ß√£o da aplica√ß√£o.
‚Äì O n√∫mero 1 indica que o processo foi encerrado por um erro (sa√≠da com falha).
‚Äì Uma sa√≠da com 0 indicaria encerramento com sucesso.

‚úÖ Quando isso √© √∫til?
Esse tipo de tratamento √© importante para:
‚Äì Evitar que a aplica√ß√£o seja finalizada de forma silenciosa.
‚Äì Fazer log de erros cr√≠ticos.
‚Äì Finalizar o processo de forma controlada e consciente.

üì¶ O que √© o m√≥dulo path
O path √© um m√≥dulo nativo do Node.js usado para trabalhar com caminhos de arquivos e diret√≥rios. Ele oferece m√©todos que ajudam a montar caminhos de forma segura, padronizada e compat√≠vel com qualquer sistema operacional (Windows, macOS, Linux, etc).

üí° Por que usar path.join(...)?
Em vez de escrever manualmente o caminho como uma string ("./files/starter.txt"), foi usado:

path.join(__dirname, "files", "starter.txt")

üß© Explicando cada parte:
__dirname: constante especial do Node.js que retorna o caminho absoluto da pasta onde est√° o arquivo atual.

path.join(...): m√©todo que concatena as partes do caminho usando o separador correto do sistema operacional (/ no Linux/macOS, \ no Windows).

üéØ Vantagens
‚úÖ Garante que o caminho funcione corretamente em qualquer sistema operacional.

‚úÖ Evita erros causados por separadores de pastas incorretos.

‚úÖ Torna o c√≥digo mais robusto e confi√°vel.

üìù Escrita de Arquivo com fs.writeFile
‚úÖ O que foi adicionado
Foi inclu√≠do um novo bloco de c√≥digo que escreve o conte√∫do "Nice to meet you." dentro de um arquivo chamado reply.txt, localizado na pasta files:

fs.writeFile(
¬† path.join(__dirname, "files", "reply.txt"),
¬† "Nice to meet you.",
¬† (err) => {
¬† ¬† if (err) throw err;
¬† ¬† console.log("Write complete");
¬† }
);

üì¶ O que √© fs.writeFile
O m√©todo writeFile pertence ao m√≥dulo nativo fs (File System) do Node.js. Ele serve para criar ou sobrescrever um arquivo com o conte√∫do fornecido.

üß© Explicando cada parte:
fs.writeFile: m√©todo usado para escrever dados em um arquivo. Se o arquivo n√£o existir, ele ser√° criado automaticamente. Se j√° existir, ser√° sobrescrito.

path.join(__dirname, "files", "reply.txt"): monta de forma segura o caminho do novo arquivo chamado reply.txt, dentro da pasta files, considerando a pasta atual do arquivo como base (__dirname).

"Nice to meet you.": conte√∫do que ser√° escrito no arquivo.

(err) => { ... }: fun√ß√£o de callback executada ap√≥s a tentativa de escrita.
¬† - Se houver erro (err), ele ser√° lan√ßado com throw err.
¬† - Se der tudo certo, exibe a mensagem "Write complete" no terminal.

üéØ Observa√ß√£o importante
Esse m√©todo √© ass√≠ncrono. Isso significa que ele n√£o bloqueia o restante do c√≥digo enquanto est√° executando a escrita no arquivo.

‚úçÔ∏è Adicionando conte√∫do com fs.appendFile
‚úÖ O que esse c√≥digo faz
Esse trecho de c√≥digo adiciona (ou cria, se n√£o existir) o texto "Testing text." ao final de um arquivo chamado test.txt, localizado dentro da pasta files:

fs.appendFile(
¬† path.join(__dirname, "files", "test.txt"),
¬† "Testing text.",
¬† (err) => {
¬† ¬† if (err) throw err;
¬† ¬† console.log("Append complete");
¬† }
);

üì¶ O que √© fs.appendFile
O m√©todo appendFile √© fornecido pelo m√≥dulo fs (File System) do Node.js. Ele serve para adicionar dados ao final de um arquivo existente.
Se o arquivo n√£o existir, ele ser√° criado automaticamente.

üß© Explicando cada parte:
fs.appendFile: m√©todo usado para anexar texto ao final de um arquivo, sem apagar o que j√° existe.

path.join(__dirname, "files", "test.txt"): monta o caminho absoluto at√© o arquivo test.txt, dentro da pasta files, a partir do diret√≥rio atual onde est√° o script (__dirname).

"Testing text.": √© o conte√∫do que ser√° adicionado no final do arquivo.

(err) => { ... }: fun√ß√£o de callback executada ap√≥s a tentativa de adicionar o conte√∫do.
¬† - Se houver erro (err), ele √© tratado com throw err.
¬† - Se tudo ocorrer corretamente, ser√° exibida a mensagem "Append complete" no terminal.

üß† Dica
Esse m√©todo tamb√©m √© ass√≠ncrono, o que significa que o Node.js continuar√° executando o restante do c√≥digo enquanto a escrita ocorre em segundo plano.

fs.writeFile(
  path.join(__dirname, "files", "reply.txt"),
  "Nice to meet you.",
  (err) => {
    if (err) throw err;

    console.log("Write complete");

    fs.appendFile(
      path.join(__dirname, "files", "reply.txt"),
      "\n\nYes it is.",
      (err) => {
        if (err) throw err;

        console.log("Append complete");
      }
    );
  }
);

‚úçÔ∏è Encadeando a√ß√µes com fs.writeFile e fs.appendFile
Essa modifica√ß√£o foi feita para realizar duas a√ß√µes em sequ√™ncia no mesmo arquivo reply.txt:

Primeiro, o conte√∫do "Nice to meet you." √© escrito no arquivo com fs.writeFile.

Em seguida, dentro do callback de fs.writeFile, √© chamado o fs.appendFile para adicionar o texto "\n\nYes it is.".

üß† Contexto da altera√ß√£o
A ideia aqui √© garantir que o texto s√≥ seja adicionado ap√≥s a escrita ter sido completada com sucesso. Isso √© importante porque as opera√ß√µes com o m√≥dulo fs s√£o ass√≠ncronas, ou seja, n√£o ocorrem de forma imediata e ordenada a menos que sejam controladas.

üí° Benef√≠cio dessa abordagem
Ao encadear o appendFile dentro do callback do writeFile, garantimos que:

O arquivo j√° foi criado e escrito com sucesso;

A adi√ß√£o de conte√∫do ser√° feita somente depois disso, evitando conflitos ou tentativas de adicionar texto a um arquivo que ainda n√£o est√° pronto.

üîÑ fs.rename()
‚úÖ O que √©?
fs.rename √© um m√©todo do m√≥dulo fs (file system) que permite renomear ou mover um arquivo.

üß± Estrutura usada no exemplo:
fs.rename(
‚ÄÉcaminhoAtual,‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ// caminho completo do arquivo que ser√° renomeado
‚ÄÉnovoCaminho,‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ// novo nome ou novo local para onde o arquivo ser√° movido
‚ÄÉcallback‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ// fun√ß√£o de callback com tratamento de erro
)

üß† No c√≥digo:
fs.rename(
‚ÄÉpath.join(__dirname, "files", "reply.txt"),
‚ÄÉpath.join(__dirname, "files", "new-reply.txt"),
‚ÄÉ(err) => {
‚ÄÉ‚ÄÉif (err) throw err;
‚ÄÉ‚ÄÉconsole.log("Rename complete");
‚ÄÉ}
);

üßæ O que est√° acontecendo:
Primeiro argumento: caminho do arquivo atual "reply.txt" dentro da pasta "files".

Segundo argumento: novo nome do arquivo "new-reply.txt", no mesmo diret√≥rio.

Callback: se houver erro, ele ser√° lan√ßado; caso contr√°rio, a mensagem "Rename complete" ser√° exibida.

üõ°Ô∏è Por que usar path.join() aqui?
Porque ele garante que os caminhos dos arquivos sejam seguros e compat√≠veis com todos os sistemas operacionais, evitando erros ao construir o caminho completo.

‚úÖ Resultado:
O arquivo "reply.txt" ser√° renomeado para "new-reply.txt".

O conte√∫do permanece o mesmo:
‚ÄÉNice to meet you.
‚ÄÉ
‚ÄÉYes it is.

üîÑ Adapta√ß√£o para uso de Promises com async/await no m√≥dulo fs
‚úÖ O que mudou?
Em vez de usar os m√©todos de callback do m√≥dulo fs, agora foi usada a vers√£o baseada em Promises, acessada atrav√©s de require("fs").promises, armazenada na constante fsPromises.

üì¶ 1. const fsPromises = require("fs").promises;
Importa a vers√£o do m√≥dulo fs que trabalha com Promises.
Isso permite o uso de async/await, o que torna o c√≥digo mais limpo e f√°cil de ler, especialmente quando se tem v√°rias opera√ß√µes ass√≠ncronas em sequ√™ncia.

üöÄ 2. Fun√ß√£o ass√≠ncrona fileOps
Criamos uma fun√ß√£o async chamada fileOps, para poder usar await dentro dela.

üß™ Bloco try...catch
Envolve todas as opera√ß√µes ass√≠ncronas para capturar qualquer erro que possa acontecer no meio do processo.
Se algo der errado, o erro ser√° exibido no console e a execu√ß√£o ser√° interrompida com seguran√ßa.

üìñ Leitura do arquivo:
const data = await fsPromises.readFile(path.join(__dirname, "files", "starter.txt"), "utf8");

M√©todo: fsPromises.readFile

Par√¢metros: o caminho completo do arquivo e a codifica√ß√£o "utf8"

Retorno: o conte√∫do do arquivo, que √© armazenado na vari√°vel data.

üóëÔ∏è Remo√ß√£o do arquivo original:
await fsPromises.unlink(path.join(__dirname, "files", "starter.txt"));

M√©todo: fsPromises.unlink

Fun√ß√£o: exclui (deleta) o arquivo do caminho fornecido.

‚úçÔ∏è Escrita do conte√∫do original em novo arquivo:
await fsPromises.writeFile(path.join(__dirname, "files", "promise-write.txt"), data);

Escreve o conte√∫do lido do starter.txt dentro do novo arquivo promise-write.txt.

‚ûï Adi√ß√£o de novo texto:
await fsPromises.appendFile(path.join(__dirname, "files", "promise-write.txt"), "\n\nNice to meet you.");

M√©todo: fsPromises.appendFile

Fun√ß√£o: adiciona o texto no final do arquivo promise-write.txt.

O texto \n\nNice to meet you. adiciona uma quebra de linha dupla seguida da frase.

üè∑Ô∏è Renomeando o arquivo:
await fsPromises.rename(path.join(__dirname, "files", "promise-write.txt"), path.join(__dirname, "files", "promise-complete.txt"));

Renomeia promise-write.txt para promise-complete.txt.

üìñ Leitura final (sem console):
const newData = await fsPromises.readFile(path.join(__dirname, "files", "promise-complete.txt"), "utf8");

O conte√∫do final do arquivo √© lido, mas n√£o exibido no console.

Fica armazenado na vari√°vel newData.

‚úÖ Resultado:
O conte√∫do de starter.txt √© movido para um novo arquivo chamado promise-complete.txt.

No caminho, o arquivo √© deletado, o conte√∫do √© reaproveitado, um novo texto √© adicionado, e o nome do arquivo √© alterado.

Tudo isso de forma limpa e organizada com async/await.

üìå Diferen√ßa entre readFile e createReadStream

Anteriormente, utilizamos o m√©todo readFile, que l√™ o conte√∫do inteiro do arquivo de uma vez s√≥, armazenando tudo na mem√≥ria. Isso funciona bem para arquivos pequenos, mas pode causar problemas de performance com arquivos grandes.

O m√©todo createReadStream, por outro lado, trabalha com streams, que s√£o peda√ßos do arquivo enviados e processados aos poucos. Isso consome menos mem√≥ria e permite processar arquivos grandes com mais efici√™ncia.

üìå O que √© um stream

Um stream √© um tipo de abstra√ß√£o em Node.js que permite ler e escrever dados de forma cont√≠nua. Em vez de esperar todo o conte√∫do estar pronto (como acontece com readFile), com streams voc√™ pode come√ßar a processar os dados assim que eles come√ßam a chegar.

fs.createReadStream() cria um stream de leitura.

fs.createWriteStream() cria um stream de escrita.

üìå pipe()

O m√©todo pipe() conecta dois streams: ele direciona automaticamente os dados que chegam no stream de leitura (rs) para o stream de escrita (ws), sem precisar tratar cada peda√ßo individualmente.

√â uma maneira mais limpa e eficiente de transferir dados de leitura para escrita, al√©m de tratar o fluxo de forma autom√°tica, cuidando dos eventos internamente.

üìå const fs = require("fs");
Importa o m√≥dulo interno fs, que oferece funcionalidades para manipular o sistema de arquivos, como leitura, escrita, renomea√ß√£o, entre outras. Retorna um objeto com diversos m√©todos, como createReadStream, createWriteStream, readFile, writeFile, etc.

üìå const rs = fs.createReadStream("./files/lorem.txt", { encoding: "utf8" });
Cria uma stream de leitura a partir do arquivo "lorem.txt" que est√° na pasta "files".
Essa express√£o retorna um objeto do tipo ReadableStream, que emite eventos conforme os dados v√£o sendo lidos.

Par√¢metros:

path: caminho do arquivo a ser lido.

options (opcional): neste caso, foi definido { encoding: "utf8" }, o que garante que o conte√∫do lido ser√° tratado como texto (string), e n√£o como um Buffer.

üìå const ws = fs.createWriteStream("./files/new-lorem.txt");
Cria uma stream de escrita que vai gerar (ou sobrescrever, se j√° existir) o arquivo "new-lorem.txt" na mesma pasta "files".
Retorna um objeto do tipo WritableStream, usado para escrever os dados conforme forem recebidos.

N√£o foi passado o encoding, ent√£o os dados recebidos ser√£o escritos da forma como forem transmitidos pela stream de leitura.

üìå C√≥digo comentado:

// rs.on("data", (dataChunk) => {
// ws.write(dataChunk);
// });

Esse c√≥digo √© uma forma manual de fazer a leitura e escrita com streams. Vamos entender linha por linha:

rs.on("data", callback): o m√©todo .on() registra um ouvinte de evento. O evento "data" √© emitido toda vez que um peda√ßo do arquivo (chunk) √© lido.

O callback recebe o dataChunk, que √© um peda√ßo do conte√∫do do arquivo (em texto, j√° que foi passado "utf8" no rs).

Dentro do callback, o m√©todo ws.write(dataChunk) escreve cada peda√ßo no stream de escrita, ou seja, no arquivo "new-lorem.txt".

Esse m√©todo funciona bem e d√° maior controle, mas √© mais verboso e pode exigir controle adicional, como tratamento de erros e encerramento do stream.

üìå Alternativa criada: rs.pipe(ws)

Essa linha faz exatamente o mesmo que o c√≥digo acima, por√©m de forma muito mais simples e elegante.
O m√©todo .pipe() est√° dispon√≠vel em streams leg√≠veis (ReadableStream) e serve para encaminhar diretamente os dados para uma stream de escrita (WritableStream).

Par√¢metro:

Recebe como argumento uma WritableStream, que no caso √© ws.

Retorno:

Retorna o stream de escrita (ws) para permitir encadeamento de m√©todos, se necess√°rio.

Vantagens:

Cuida automaticamente de eventos como data, end, error e at√© do fechamento dos streams.

Menos c√≥digo, menos chances de erro.

‚úÖ Resumo da diferen√ßa:

rs.on("data", ...) + ws.write(...)
‚û§ Mais controle manual. √ötil quando voc√™ precisa processar ou transformar os dados antes de gravar.
‚û§ Requer tratamento extra para eventos como end e error.

rs.pipe(ws)
‚û§ Solu√ß√£o ideal quando voc√™ s√≥ quer copiar dados de um lugar para outro.
‚û§ Cuida automaticamente de tudo, mais limpo e eficiente.

üìå if (!fs.existsSync("./new")) { ... }
Verifica se o diret√≥rio "./new" n√£o existe.

fs.existsSync(path)
‚û§ √â um m√©todo s√≠ncrono que verifica se um determinado caminho (arquivo ou pasta) existe.
‚û§ Retorna true se existir, false se n√£o existir.
‚û§ Recebe como par√¢metro uma string com o caminho a ser verificado.

üìå fs.mkdir("./new", (err) => { ... });
Se o diret√≥rio n√£o existir, essa linha cria o diret√≥rio "new".

fs.mkdir(path, callback)
‚û§ Cria um diret√≥rio em disco.
‚û§ O primeiro argumento √© o caminho (string).
‚û§ O segundo √© uma fun√ß√£o de callback que recebe o erro, se houver.
‚û§ Se a cria√ß√£o for bem-sucedida, o callback √© executado sem erro.
‚û§ Caso haja erro, ele ser√° lan√ßado com throw err.

Retorno:

A fun√ß√£o n√£o retorna diretamente um valor √∫til, o resultado √© tratado dentro do callback.

üìå console.log("Directory created");
Essa mensagem ser√° exibida no terminal somente se o diret√≥rio for criado com sucesso.

üìå if (fs.existsSync("./new")) { ... }
Esse segundo bloco verifica se o diret√≥rio "./new" existe. Se existir, ele ser√° removido.

üìå fs.rmdir("./new", (err) => { ... });
Remove o diret√≥rio "new".

fs.rmdir(path, callback)
‚û§ Remove um diret√≥rio vazio.
‚û§ Se o diret√≥rio contiver arquivos, o m√©todo lan√ßar√° um erro.
‚û§ Mesmo esquema: recebe o caminho como string e um callback com o poss√≠vel erro.

‚úÖ Resumo pr√°tico

Primeiro, verifica se o diret√≥rio "new" n√£o existe. Se for o caso, ele cria o diret√≥rio.

Depois, verifica se o diret√≥rio existe. Se existir, ele remove esse diret√≥rio.

Os dois blocos podem acontecer juntos dependendo do tempo de execu√ß√£o (por exemplo, se o primeiro bloco criar o diret√≥rio e o segundo bloco for executado em seguida, ele j√° o remove).